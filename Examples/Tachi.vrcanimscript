# Tachi.vrcanimscript
#
# This is a VRC animation script. It lets you create VRChat parameters, menus, animation
# controllers, and simple animations in one compact text file.
#
# Whitespace (including newlines) is insignificant in this file, and comments begin with `#`.
# Indent as you please. Strings are delimited with double quotes; in most cases you can leave off
# the double quotes if the string is just one word (alphanumeric characters plus underscore).

# Name of your avatar. This can be any valid identifier (no spaces) and is only used for internal
# names.
avatar Tachi

# The Unity name of your root object. This is the one containing the avatar descriptor.
rootobject "jacob-ovrick-tachi-ik (1)"

# Declare your parameters here. Right now only booleans and floats are supported. The syntax is:
#
#   saved? param NAME: TYPE = EXPRESSION
saved param Wrench: bool = false
saved param FloatAndSplat: bool = false
saved param Geddan: bool = false
saved param Pants: bool = true
saved param TailSwish: bool = false
saved param Hoverboard: bool = false
param GroundDistance: float = 0.0

# Declare your menu items here. Submenus and menu items other than toggles are currently
# unsupported.
menuitem Wrench
    icon item_sword
    toggle Wrench
menuitem "ゲッダン"
    icon person_dance
    toggle Geddan
menuitem "Float & Splat"
    icon hand_waving
    toggle FloatAndSplat
menuitem Pants
    icon symbol_heart
    toggle Pants
menuitem TailSwish
    icon symbol_paw
    toggle TailSwish
menuitem Hoverboard
    icon symbol_magic
    toggle Hoverboard

# Your action controller goes here.
#
# VRC playable layer control and VRC animator tracking control behaviors are automatically added
# as necessary.
controller action
    # An animation layer.
    layer Action
        # There must be one initial state. The names don't matter; they're only used for
        # identification.
        initial state Idle
            # These are transitions with conditions.
            goto Geddan if Geddan
            goto FloatAndSplat if FloatAndSplat
        state Geddan
            # `play` plays a `.anim` asset: in this case, `BaileGETDOWN.anim`.
            play BaileGETDOWN
            # Negation of booleans can be done with `!`. This one goes to Idle if Geddan is false.
            goto Idle if !Geddan
        state FloatAndSplat
            play "Float & Splat"
            goto Idle if !FloatAndSplat

# Your FX controller goes here.
controller fx
    layer Wrench
        initial state WrenchOff
            # `do` specifies an "inline animation". These are simple one-off animations that
            # VRCAnimScript automatically generates as necessary. They're useful when you don't
            # want to bother making a whole `.anim` file in Unity.
            do
                # The syntax here is
                #
                #    GAMEOBJECT::COMPONENT.PROPERTY = EXPRESSION
                #
                # * GAMEOBJECT is the Unity name of the game object, as a string. It can be
                #   anywhere in the hierarchy below your root object.
                # * COMPONENT is the type of the component to be animated as a string, such as
                #   Transform or SkinnedMeshRenderer.
                # * PROPERTY is the path of the property to be animated on the component. For
                #   example, `blendShape.MyBlendShape`.
                # * EXPRESSION is the value to animate to.
                #
                # Valid expressions include numbers (ints and floats are internally the same thing)
                # and 2/3/4-element vectors, notated as `vecN(NUMBER, NUMBER, ...)`. Internally,
                # vectors turn into multiple float properties, one for each element of the vector.
                # For example, `Wrench::Transform.m_LocalScale = vec3(0, 0, 0)` is the same as:
                #
                #   Wrench::Transform.m_LocalScale.x = 0
                #   Wrench::Transform.m_LocalScale.y = 0
                #   Wrench::Transform.m_LocalScale.z = 0
                Wrench::Transform.m_LocalScale = vec3(0, 0, 0)
            goto WrenchOn if Wrench
        state WrenchOn
            do
                Wrench::Transform.m_LocalScale = vec3(1, 1, 1)
            goto WrenchOff if !Wrench

    layer Pants
        initial state PantsOn
            do
                # If you're familiar with Unity animation paths, you may be expecting to write this
                # as `m_Materials.Array.data[6]`. In VRCAnimScript, the `.Array.data` is implied, so
                # you can just write `m_Materials[6]`.
                Body::SkinnedMeshRenderer.m_Materials[6] = (Material)TachiHidden
                Body::SkinnedMeshRenderer.m_Materials[7] = (Material)"T_Tachi_ClothesHair.004"
            goto PantsOff if !Pants
        state PantsOff
            do
                Body::SkinnedMeshRenderer.m_Materials[6] = (Material)"T_Tachi_Body.008"
                Body::SkinnedMeshRenderer.m_Materials[7] = (Material)TachiHidden
            goto PantsOn if Pants

    additive layer TailSwish
        initial state TailSwishOn
            loop do
                at time 0.
                    Tail_2::Transform.localEulerAnglesRaw.z = 3.25703 curve(-17.9473, -17.9473)
                    Tail_4::Transform.localEulerAnglesRaw.z = -3.63321 curve(-25.7805, -25.7805)
                    Tail_6::Transform.localEulerAnglesRaw.z = -13.5705 curve(-23.8142, -23.8142)
                    Tail_8::Transform.localEulerAnglesRaw.z = -17.5485 curve(4.90953, 4.90953)
                at time 1.13333
                    Tail_2::Transform.localEulerAnglesRaw.z = -9.04968 curve(3.06607, 3.06607)
                    Tail_4::Transform.localEulerAnglesRaw.z = -8.84352 curve(19.4801, 19.4801)
                    Tail_6::Transform.localEulerAnglesRaw.z = -3.06182 curve(36.5213, 36.5213)
                    Tail_8::Transform.localEulerAnglesRaw.z = 10.8043 curve(29.3747, 29.3747)
                at time 2.26667
                    Tail_2::Transform.localEulerAnglesRaw.z = 5.79265 curve(14.8813, 14.8813)
                    Tail_4::Transform.localEulerAnglesRaw.z = 12.4767 curve(6.3003, 6.3003)
                    Tail_6::Transform.localEulerAnglesRaw.z = 16.6323 curve(-12.7071, -12.7071)
                    Tail_8::Transform.localEulerAnglesRaw.z = 6.74419 curve(-34.2843, -34.2843)
                at time 3.4
                    Tail_2::Transform.localEulerAnglesRaw.z = 3.25703 curve(-17.9473, -17.9473)
                    Tail_4::Transform.localEulerAnglesRaw.z = -3.63321 curve(-25.7805, -25.7805)
                    Tail_6::Transform.localEulerAnglesRaw.z = -13.5705 curve(-23.8142, -23.8142)
                    Tail_8::Transform.localEulerAnglesRaw.z = -17.5485 curve(4.90953, 4.90953)
            goto TailSwishOff if !TailSwish
        state TailSwishOff
            do
                Tail_2::Transform.localEulerAnglesRaw.z = 0
                Tail_4::Transform.localEulerAnglesRaw.z = 0
                Tail_6::Transform.localEulerAnglesRaw.z = 0
                Tail_8::Transform.localEulerAnglesRaw.z = 0
            goto TailSwishOn if TailSwish

    layer Hoverboard
        initial state HoverboardOff
            do
                Hoverboard::GameObject.m_IsActive = 0
            goto HoverboardOn if Hoverboard && GroundDistance > 0.5
        state HoverboardOn
            do
                Hoverboard::GameObject.m_IsActive = 1
            goto HoverboardOff if !(Hoverboard && GroundDistance > 0.5)
