# Tachi.vrcanimscript
#
# This is a VRC animation script. It lets you create VRChat parameters, menus, animation
# controllers, and simple animations in one compact text file.
#
# Whitespace (including newlines) is insignificant in this file, and comments begin with `#`.
# Indent as you please. Strings are delimited with double quotes; in most cases you can leave off
# the double quotes if the string is just one word (alphanumeric characters plus underscore).

# Name of your avatar. This can be any valid identifier (no spaces) and is only used for internal
# names.
avatar Tachi

# The Unity name of your root object. This is the one containing the avatar descriptor.
rootobject "jacob-ovrick-tachi-ik (1)"

# Declare your parameters here. Right now only booleans and floats are supported. The syntax is:
#
#   saved? param NAME: TYPE = EXPRESSION
saved param Wrench: bool = false
saved param FloatAndSplat: bool = false
saved param Geddan: bool = false
saved param Pants: bool = true
saved param TailSwish: bool = false
saved param Hoverboard: bool = false
saved param EyesClosed: float = 1.0
param GroundDistance: float = 0.0

# Declare your menu items here. The type of the item is inferred based on the type of the parameter
# being controlled. Submenus are currently unsupported.
menuitem Wrench
    icon item_sword
    controls Wrench
menuitem "ゲッダン"
    icon person_dance
    controls Geddan
menuitem "Float & Splat"
    icon hand_waving
    controls FloatAndSplat
menuitem Pants
    icon symbol_heart
    controls Pants
menuitem TailSwish
    icon symbol_paw
    controls TailSwish
menuitem Hoverboard
    icon symbol_magic
    controls Hoverboard
menuitem "Eyes Closed"
    controls EyesClosed

# Your action controller goes here.
#
# VRC playable layer control and VRC animator tracking control behaviors are automatically added
# as necessary.
controller action
    # An animation layer.
    layer Action
        # There must be one initial state. The names don't matter; they're only used for
        # identification.
        initial state Idle
            # These are transitions with conditions.
            goto Geddan if Geddan
            goto FloatAndSplat if FloatAndSplat
        state Geddan
            # `play` plays a `.anim` asset: in this case, `BaileGETDOWN.anim`.
            play BaileGETDOWN
            # Negation of booleans can be done with `!`. This one goes to Idle if Geddan is false.
            goto Idle if !Geddan
        state FloatAndSplat
            play "Float & Splat"
            goto Idle if !FloatAndSplat

# Your FX controller goes here.
controller fx
    layer Wrench
        initial state WrenchOff
            # `do` specifies an "inline animation". These are simple one-off animations that
            # VRCAnimScript automatically generates as necessary. They're useful when you don't
            # want to bother making a whole `.anim` file in Unity.
            do
                # The syntax here is
                #
                #    GAMEOBJECT::COMPONENT.PROPERTY = EXPRESSION
                #
                # * GAMEOBJECT is the Unity name of the game object, as a string. It can be
                #   anywhere in the hierarchy below your root object.
                # * COMPONENT is the type of the component to be animated as a string, such as
                #   Transform or SkinnedMeshRenderer.
                # * PROPERTY is the path of the property to be animated on the component. For
                #   example, `blendShape.MyBlendShape`.
                # * EXPRESSION is the value to animate to.
                #
                # Valid expressions include numbers (ints and floats are internally the same thing)
                # and 2/3/4-element vectors, notated as `vecN(NUMBER, NUMBER, ...)`. Internally,
                # vectors turn into multiple float properties, one for each element of the vector.
                # For example, `Wrench::Transform.m_LocalScale = vec3(0, 0, 0)` is the same as:
                #
                #   Wrench::Transform.m_LocalScale.x = 0
                #   Wrench::Transform.m_LocalScale.y = 0
                #   Wrench::Transform.m_LocalScale.z = 0
                #
                # There are abbreviations you can use in place of `COMPONENT.PROPERTY`:
                #
                #  * `scale` is short for `Transform.m_LocalScale`.
                #  * `rotation` is short for `Transform.localEulerAnglesRaw`.
                #  * `active` is short for `GameObject.m_IsActive`.
                #  * `materials` is short for `SkinnedMeshRenderer.m_Materials`.
                #
                # Each of these abbreviations can be projected from, so you can write
                # `Wrench::materials[6] = (Material)myMaterial` and so forth.
                Wrench::scale = vec3(0, 0, 0)
            goto WrenchOn if Wrench
        state WrenchOn
            do
                Wrench::scale = vec3(1, 1, 1)
            goto WrenchOff if !Wrench

        layer Wrench
            loop
                if !Wrench
                    Wrench::scale = vec3(0)
                else
                    Wrench::scale = vec3(1)

    layer Pants
        initial state PantsOn
            do
                # If you're familiar with Unity animation paths, you may be expecting to write this
                # as `m_Materials.Array.data[6]`. In VRCAnimScript, the `.Array.data` is implied, so
                # you can just write `m_Materials[6]`.
                Body::materials[6] = (Material)TachiHidden
                Body::materials[7] = (Material)"T_Tachi_ClothesHair.004"
            goto PantsOff if !Pants
        state PantsOff
            do
                Body::materials[6] = (Material)"T_Tachi_Body.008"
                Body::materials[7] = (Material)TachiHidden
            goto PantsOn if Pants

    additive layer TailSwish
        initial state TailSwishOn
            loop do
                at time 0.
                    Tail_2::rotation.z = 3.25703 curve(-17.9473, -17.9473)
                    Tail_4::rotation.z = -3.63321 curve(-25.7805, -25.7805)
                    Tail_6::rotation.z = -13.5705 curve(-23.8142, -23.8142)
                    Tail_8::rotation.z = -17.5485 curve(4.90953, 4.90953)
                at time 1.13333
                    Tail_2::rotation.z = -9.04968 curve(3.06607, 3.06607)
                    Tail_4::rotation.z = -8.84352 curve(19.4801, 19.4801)
                    Tail_6::rotation.z = -3.06182 curve(36.5213, 36.5213)
                    Tail_8::rotation.z = 10.8043 curve(29.3747, 29.3747)
                at time 2.26667
                    Tail_2::rotation.z = 5.79265 curve(14.8813, 14.8813)
                    Tail_4::rotation.z = 12.4767 curve(6.3003, 6.3003)
                    Tail_6::rotation.z = 16.6323 curve(-12.7071, -12.7071)
                    Tail_8::rotation.z = 6.74419 curve(-34.2843, -34.2843)
                at time 3.4
                    Tail_2::rotation.z = 3.25703 curve(-17.9473, -17.9473)
                    Tail_4::rotation.z = -3.63321 curve(-25.7805, -25.7805)
                    Tail_6::rotation.z = -13.5705 curve(-23.8142, -23.8142)
                    Tail_8::rotation.z = -17.5485 curve(4.90953, 4.90953)
            goto TailSwishOff if !TailSwish
        state TailSwishOff
            do
                Tail_2::rotation.z = 0
                Tail_4::rotation.z = 0
                Tail_6::rotation.z = 0
                Tail_8::rotation.z = 0
            goto TailSwishOn if TailSwish

    layer Hoverboard
        initial state HoverboardOff
            do
                Hoverboard::active = false
            goto HoverboardOn if Hoverboard && GroundDistance > 0.5
        state HoverboardOn
            do
                Hoverboard::active = true
            goto HoverboardOff if !(Hoverboard && GroundDistance > 0.5)

    layer Eyelids
        blend Eyelids(EyesClosed)
            at value 0
                do
                    Body::SkinnedMeshRenderer.blendShape.EyesClosed = 0
            at value 1
                do
                    Body::SkinnedMeshRenderer.blendShape.EyesClosed = 1
